# 自定义汇编语言使用指南

## 目录
1. [概述](#概述)
2. [汇编器使用](#汇编器使用)
3. [虚拟机架构](#虚拟机架构)
4. [指令集详解](#指令集详解)
5. [语法规范](#语法规范)
6. [示例程序](#示例程序)
7. [注意事项](#注意事项)

---

## 概述

这是一个简单的基于寄存器的虚拟机及其汇编语言系统，包含：
- **汇编器 (asm)**: 将 `.s` 格式的汇编文件编译为 `.o` 格式的二进制文件
- **虚拟机 (machine)**: 执行编译后的二进制文件

### 特性
- 16个通用寄存器 (R0-R15)
- 64KB内存空间 (256×256)
- 8字节固定长度指令格式
- 两遍扫描汇编过程
- 支持标签和符号跳转

---

## 汇编器使用

### 编译和运行

```bash
# 编译汇编器和虚拟机
make

# 汇编源文件 (将 program.s 编译为 program.o)
./asm program.s

# 运行二进制文件
./machine program.o
```

### 文件格式
- **输入**: `.s` 文件 (汇编源代码)
- **输出**: `.o` 文件 (二进制机器码)

---

## 虚拟机架构

### 寄存器组
- **R0**: FLAG寄存器 - 存储条件标志
  - `FLAG_EZ` (0): 等于零
  - `FLAG_LZ` (1): 小于零
  - `FLAG_GZ` (2): 大于零
- **R1**: IP寄存器 - 指令指针 (程序计数器)
- **R2-R14**: 通用寄存器
- **R15**: 特殊用途寄存器 - I/O操作默认使用

### 内存布局
- 总容量: 65536字节 (64KB)
- 字节寻址
- 支持整型(4字节)和字符(1字节)访问

### 指令格式
每条指令固定8字节：
```
+----------------+----+----+----------------+
| 操作码(2字节)  | Rx | Ry |  常量(4字节)   |
+----------------+----+----+----------------+
  0           1    2    3   4    5    6    7
```

### 性能计数器
虚拟机在程序结束时会输出：
- **CLOCK CYCLES**: 总时钟周期数
- **MUL DIV**: 乘除法操作次数 (每次+4周期)
- **MEM READ**: 内存读取次数 (每次+9周期)
- **MEM WRITE**: 内存写入次数 (每次+9周期)

---

## 指令集详解

### 1. 算术运算指令

#### ADD - 加法
```assembly
ADD Rx, 立即数        # Rx = Rx + 立即数
ADD Rx, 标签          # Rx = Rx + 标签地址
ADD Rx, Ry           # Rx = Rx + Ry
```
**操作码**: `I_ADD_0` (0x30), `I_ADD_1` (0x31)  
**周期**: 1

#### SUB - 减法
```assembly
SUB Rx, 立即数        # Rx = Rx - 立即数
SUB Rx, 标签          # Rx = Rx - 标签地址
SUB Rx, Ry           # Rx = Rx - Ry
```
**操作码**: `I_SUB_0` (0x40), `I_SUB_1` (0x41)  
**周期**: 1

#### MUL - 乘法
```assembly
MUL Rx, 立即数        # Rx = Rx * 立即数
MUL Rx, 标签          # Rx = Rx * 标签地址
MUL Rx, Ry           # Rx = Rx * Ry
```
**操作码**: `I_MUL_0` (0x50), `I_MUL_1` (0x51)  
**周期**: 5 (基础1 + 乘法惩罚4)

#### DIV - 除法
```assembly
DIV Rx, 立即数        # Rx = Rx / 立即数
DIV Rx, 标签          # Rx = Rx / 标签地址
DIV Rx, Ry           # Rx = Rx / Ry
```
**操作码**: `I_DIV_0` (0x60), `I_DIV_1` (0x61)  
**周期**: 5 (基础1 + 除法惩罚4)  
**注意**: 除数为0会导致程序终止并报错

---

### 2. 数据传送指令

#### LOD - 加载数据
```assembly
# 立即数加载
LOD Rx, 立即数              # Rx = 立即数
LOD Rx, 标签                # Rx = 标签地址值
LOD Rx, Ry                 # Rx = Ry

# 带偏移加载
LOD Rx, Ry + 偏移          # Rx = Ry + 偏移
LOD Rx, Ry - 偏移          # Rx = Ry - 偏移

# 内存加载 (整型 4字节)
LOD Rx, (立即数)           # Rx = MEM[立即数] (4字节整型)
LOD Rx, (标签)             # Rx = MEM[标签地址] (4字节整型)
LOD Rx, (Ry)               # Rx = MEM[Ry] (4字节整型)
LOD Rx, (Ry + 偏移)        # Rx = MEM[Ry + 偏移] (4字节整型)
LOD Rx, (Ry - 偏移)        # Rx = MEM[Ry - 偏移] (4字节整型)
```
**操作码**: `I_LOD_0~5` (0x10~0x15)  
**周期**: 立即数加载1周期，内存加载10周期

#### LDC - 加载字符
```assembly
# 内存加载 (字符 1字节)
LDC Rx, (立即数)           # Rx = MEM[立即数] (1字节字符)
LDC Rx, (Ry)               # Rx = MEM[Ry] (1字节字符)
LDC Rx, (Ry + 偏移)        # Rx = MEM[Ry + 偏移] (1字节字符)
LDC Rx, (Ry - 偏移)        # Rx = MEM[Ry - 偏移] (1字节字符)
```
**操作码**: `I_LDC_3~5` (0x113~0x115)  
**周期**: 10

#### STO - 存储数据 (整型)
```assembly
STO (Rx), 立即数           # MEM[Rx] = 立即数 (4字节)
STO (Rx), 标签             # MEM[Rx] = 标签地址 (4字节)
STO (Rx), Ry              # MEM[Rx] = Ry (4字节)
STO (Rx), Ry + 偏移       # MEM[Rx] = Ry + 偏移 (4字节)
STO (Rx), Ry - 偏移       # MEM[Rx] = Ry - 偏移 (4字节)
STO (Rx + 偏移), Ry       # MEM[Rx + 偏移] = Ry (4字节)
STO (Rx - 偏移), Ry       # MEM[Rx - 偏移] = Ry (4字节)
```
**操作码**: `I_STO_0~3` (0x20~0x23)  
**周期**: 10

#### STC - 存储字符
```assembly
STC (Rx), 立即数           # MEM[Rx] = 立即数 (1字节)
STC (Rx), Ry              # MEM[Rx] = Ry (1字节)
STC (Rx), Ry + 偏移       # MEM[Rx] = Ry + 偏移 (1字节)
STC (Rx), Ry - 偏移       # MEM[Rx] = Ry - 偏移 (1字节)
STC (Rx + 偏移), Ry       # MEM[Rx + 偏移] = Ry (1字节)
STC (Rx - 偏移), Ry       # MEM[Rx - 偏移] = Ry (1字节)
```
**操作码**: `I_STC_0~3` (0x120~0x123)  
**周期**: 10

---

### 3. 控制流指令

#### TST - 测试
```assembly
TST Rx                    # 测试Rx的值，设置FLAG寄存器
                          # Rx == 0 -> FLAG = FLAG_EZ (0)
                          # Rx < 0  -> FLAG = FLAG_LZ (1)
                          # Rx > 0  -> FLAG = FLAG_GZ (2)
```
**操作码**: `I_TST_0` (0x70)  
**周期**: 1

#### JMP - 无条件跳转
```assembly
JMP 标签                  # 跳转到标签地址
JMP Rx                   # 跳转到Rx中的地址
```
**操作码**: `I_JMP_0` (0x80), `I_JMP_1` (0x81)  
**周期**: 1

#### JEZ - 等于零跳转
```assembly
JEZ 标签                  # 如果FLAG == FLAG_EZ，跳转到标签
JEZ Rx                   # 如果FLAG == FLAG_EZ，跳转到Rx
```
**操作码**: `I_JEZ_0` (0x82), `I_JEZ_1` (0x83)  
**周期**: 1

#### JLZ - 小于零跳转
```assembly
JLZ 标签                  # 如果FLAG == FLAG_LZ，跳转到标签
JLZ Rx                   # 如果FLAG == FLAG_LZ，跳转到Rx
```
**操作码**: `I_JLZ_0` (0x84), `I_JLZ_1` (0x85)  
**周期**: 1

#### JGZ - 大于零跳转
```assembly
JGZ 标签                  # 如果FLAG == FLAG_GZ，跳转到标签
JGZ Rx                   # 如果FLAG == FLAG_GZ，跳转到Rx
```
**操作码**: `I_JGZ_0` (0x86), `I_JGZ_1` (0x87)  
**周期**: 1

---

### 4. 输入输出指令

#### OTC - 输出字符
```assembly
OTC                       # 输出R15中的字符 (ASCII)
```
**操作码**: `I_OTC` (0x02)  
**周期**: 1

#### OTI - 输出整数
```assembly
OTI                       # 输出R15中的整数 (十进制)
```
**操作码**: `I_OTI` (0x03)  
**周期**: 1

#### OTS - 输出字符串
```assembly
OTS                       # 输出R15指向的字符串 (以\0结尾)
```
**操作码**: `I_OTS` (0x04)  
**周期**: 1

#### ITC - 输入字符
```assembly
ITC                       # 从标准输入读取字符到R15 (跳过空白符)
```
**操作码**: `I_ITC` (0x05)  
**周期**: 1

#### ITI - 输入整数
```assembly
ITI                       # 从标准输入读取整数到R15
```
**操作码**: `I_ITI` (0x06)  
**周期**: 1

---

### 5. 其他指令

#### NOP - 空操作
```assembly
NOP                       # 无操作，占位符
```
**操作码**: `I_NOP` (0x01)  
**周期**: 1

#### END - 程序结束
```assembly
END                       # 终止程序执行，输出统计信息
```
**操作码**: `I_END` (0x00)  
**周期**: 1

#### DBN - 定义字节块
```assembly
DBN 字节值, 重复次数      # 在内存中定义重复的字节
```
**示例**: `DBN 0, 100`    # 定义100个0字节

#### DBS - 定义字节序列
```assembly
DBS 字节1, 字节2, ...     # 在内存中定义字节序列
```
**示例**: `DBS 72, 101, 108, 108, 111, 0`  # 定义字符串 "Hello"

---

## 语法规范

### 1. 标签定义
```assembly
标签名:
```
- 标签名由字母、数字、下划线组成，必须以字母或下划线开头
- 最多支持100个标签
- 标签不区分大小写

### 2. 寄存器命名
```assembly
R0, R1, R2, ..., R15
```
- 必须使用大写字母R
- 后跟0-15的数字

### 3. 注释
```assembly
# 这是一行注释
```
- 使用 `#` 开头
- 注释到行末

### 4. 立即数
```assembly
123          # 十进制整数
-456         # 负数
```
- 只支持十进制表示

### 5. 空白符
- 空格、制表符、回车、换行会被忽略
- 可用于格式化代码

---

## 示例程序

### 示例1: Hello World
```assembly
# Hello World程序
    LOD R15, hello_str    # R15 = hello_str的地址
    OTS                   # 输出字符串
    END                   # 结束程序

hello_str:
    DBS 72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 0
    # "Hello World\0"
```

### 示例2: 累加1到10
```assembly
    LOD R2, 0             # R2 = 0 (累加器)
    LOD R3, 1             # R3 = 1 (计数器)
    LOD R4, 10            # R4 = 10 (上限)

loop:
    ADD R2, R3            # R2 = R2 + R3
    ADD R3, 1             # R3 = R3 + 1
    SUB R5, R3            # R5 = R3
    SUB R5, R4            # R5 = R3 - 10
    TST R5                # 测试 R5
    JLZ loop              # 如果 R5 < 0，继续循环
    JEZ loop              # 如果 R5 == 0，继续循环

    LOD R15, R2           # 将结果加载到R15
    OTI                   # 输出结果
    END
```

### 示例3: 数组求和
```assembly
    LOD R2, array         # R2 = 数组起始地址
    LOD R3, 0             # R3 = 累加器
    LOD R4, 0             # R4 = 索引

sum_loop:
    LOD R5, (R2)          # R5 = MEM[R2] 读取数组元素
    TST R5                # 测试是否为0 (结束标记)
    JEZ done              # 如果为0，结束循环
    ADD R3, R5            # R3 = R3 + R5 累加
    ADD R2, 4             # R2 = R2 + 4 移动到下一个整数
    JMP sum_loop          # 继续循环

done:
    LOD R15, R3           # 将结果加载到R15
    OTI                   # 输出结果
    END

array:
    DBN 5, 1              # array[0] = 5
    DBN 10, 1             # array[1] = 10
    DBN 15, 1             # array[2] = 15
    DBN 0, 1              # array[3] = 0 (结束标记)
```

### 示例4: 条件判断
```assembly
    ITI                   # 输入整数到R15
    LOD R2, R15           # R2 = 输入的数
    TST R2                # 测试R2
    JGZ positive          # 如果 > 0，跳转到positive
    JLZ negative          # 如果 < 0，跳转到negative

zero:
    LOD R15, msg_zero
    OTS
    JMP done

positive:
    LOD R15, msg_pos
    OTS
    JMP done

negative:
    LOD R15, msg_neg
    OTS

done:
    END

msg_zero:
    DBS 90, 101, 114, 111, 0       # "Zero\0"
msg_pos:
    DBS 80, 111, 115, 105, 116, 105, 118, 101, 0  # "Positive\0"
msg_neg:
    DBS 78, 101, 103, 97, 116, 105, 118, 101, 0   # "Negative\0"
```

---

## 注意事项

### 1. 汇编器限制
- ⚠️ **标签限制**: 最多100个标签
- ⚠️ **两遍扫描**: 汇编器执行两遍扫描，第一遍收集标签，第二遍生成代码
- ⚠️ **标签重复**: 重复定义标签会导致汇编错误
- ⚠️ **文件扩展名**: 输入文件必须以 `.s` 结尾，输出自动为 `.o`

### 2. 虚拟机限制
- ⚠️ **内存限制**: 总内存64KB，超出会导致段错误
- ⚠️ **除零错误**: 除法指令除数为0会立即终止程序
- ⚠️ **寄存器范围**: 只有R0-R15，访问其他寄存器会导致未定义行为
- ⚠️ **指令对齐**: 指令必须8字节对齐，IP寄存器每次增加8

### 3. 特殊寄存器使用
- ⚠️ **R0 (FLAG)**: 自动被TST指令修改，不应手动设置
- ⚠️ **R1 (IP)**: 程序计数器，跳转指令会修改它
- ⚠️ **R15**: I/O操作的默认寄存器

### 4. 内存访问
- ⚠️ **整型对齐**: 使用LOD/STO访问整型时，建议地址4字节对齐
- ⚠️ **字符访问**: 使用LDC/STC访问字符，只操作1字节
- ⚠️ **字符串**: 字符串必须以0结尾，OTS指令依赖此特性

### 5. 性能考虑
- 💡 **乘除法代价高**: 每次乘除法增加4个额外周期
- 💡 **内存访问代价高**: 每次内存读写增加9个额外周期
- 💡 **优化建议**: 尽量使用寄存器操作，减少内存访问

### 6. 数据定义
- ⚠️ **DBN**: 用于定义重复的字节，适合初始化数组或缓冲区
- ⚠️ **DBS**: 用于定义字节序列，适合定义字符串或小型数据表
- ⚠️ **位置敏感**: 数据定义会占用代码空间，注意不要让IP执行到数据区

### 7. 调试技巧
- 💡 使用NOP指令作为断点占位符
- 💡 程序结束时会输出详细的性能统计
- 💡 合理使用标签命名，便于理解跳转流程
- 💡 在循环和条件分支中使用注释说明逻辑

### 8. 常见错误
```
error: too many label          # 标签超过100个
error: label xxx already exist # 标签重复定义
error: divide by zero          # 除数为0
error: invalid opcode          # 无效指令码
error: open xxx failed         # 文件打开失败
syntax error: line xxx         # 语法错误
```

---

## 附录: 指令操作码速查表

| 指令 | 操作码 | 指令 | 操作码 | 指令 | 操作码 | 指令 | 操作码 |
|------|--------|------|--------|------|--------|------|--------|
| END  | 0x00   | NOP  | 0x01   | OTC  | 0x02   | OTI  | 0x03   |
| OTS  | 0x04   | ITC  | 0x05   | ITI  | 0x06   | -    | -      |
| LOD_0| 0x10   | LOD_1| 0x11   | LOD_2| 0x12   | LOD_3| 0x13   |
| LDC_3| 0x113  | LOD_4| 0x14   | LDC_4| 0x114  | LOD_5| 0x15   |
| LDC_5| 0x115  | STO_0| 0x20   | STC_0| 0x120  | STO_1| 0x21   |
| STC_1| 0x121  | STO_2| 0x22   | STC_2| 0x122  | STO_3| 0x23   |
| STC_3| 0x123  | ADD_0| 0x30   | ADD_1| 0x31   | SUB_0| 0x40   |
| SUB_1| 0x41   | MUL_0| 0x50   | MUL_1| 0x51   | DIV_0| 0x60   |
| DIV_1| 0x61   | TST_0| 0x70   | JMP_0| 0x80   | JMP_1| 0x81   |
| JEZ_0| 0x82   | JEZ_1| 0x83   | JLZ_0| 0x84   | JLZ_1| 0x85   |
| JGZ_0| 0x86   | JGZ_1| 0x87   | -    | -      | -    | -      |

---

**文档版本**: 1.0  
**最后更新**: 2025-10-29
